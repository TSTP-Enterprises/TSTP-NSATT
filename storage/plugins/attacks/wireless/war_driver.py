#!/usr/bin/env python3
import logging
from pathlib import Path
from datetime import datetime
import subprocess
import shutil
import re
import time
import threading
import csv
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
                            QTextEdit, QLabel, QComboBox, QListWidget, QFrame,
                            QGroupBox, QCheckBox, QListWidgetItem, QSizePolicy,
                            QTabWidget, QTableWidget, QTableWidgetItem, QMessageBox)
from PyQt5.QtCore import QThread, pyqtSignal, Qt
from PyQt5.QtGui import QFont
import random
from threading import Lock

plugin_image_value = "/nsatt/storage/images/icons/war_driver_icon.png"


class HandshakeMonitorThread(QThread):
    """
    Monitors for WPA handshakes using a single CSV/Cap pair generated by airodump-ng.
    Ensures only 'current_scan.csv' and 'current_scan.cap' exist during the scan.
    """
    output_received = pyqtSignal(str)
    handshake_found = pyqtSignal(str, str)  # (ESSID, BSSID)
    network_found = pyqtSignal(str, str, str, str)  # (ESSID, BSSID, Channel, Band)

    def __init__(self, adapter, channel="ALL", bands=None):
        super().__init__()
        self.adapter = adapter
        self.channel = channel
        self.bands = bands or ["2.4", "5"]
        self.running = True
        self.process = None

        # Found sets
        self.found_networks = set()
        self.found_handshakes = set()

        # Locking (optional)
        self.networks_lock = Lock()
        self.handshakes_lock = Lock()

        # Paths
        self.log_dir = Path("/nsatt/logs/wireless/wardriver")
        self.wardriver_dir = Path("/nsatt/storage/saves/wireless/wardriver")
        self.storage_dir = Path("/nsatt/storage/saves/wireless/handshakes")
        for d in [self.log_dir, self.wardriver_dir, self.storage_dir]:
            d.mkdir(parents=True, exist_ok=True)

        # Single-file references
        self.csv_file = self.wardriver_dir / "current_scan.csv"
        self.cap_file = self.wardriver_dir / "current_scan.cap"

        # Remove leftover current_scan.* from previous runs
        for leftover in self.wardriver_dir.glob("current_scan.*"):
            leftover.unlink()

        # Prepare log file
        now_str = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_file = self.log_dir / f"wardriver_log_{now_str}.txt"

        # Channel Hopping (if channel=ALL)
        self.channel_hop_thread = None
        self.current_channel = None

    def log(self, message, level="INFO"):
        """Writes to a log file + emits signal to UI console."""
        stamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_msg = f"[{stamp}] [{level}] {message}"
        try:
            with open(self.log_file, "a", encoding="utf-8") as lf:
                lf.write(log_msg + "\n")
            self.output_received.emit(log_msg)
        except Exception as e:
            self.output_received.emit(f"[ERROR] Could not write to log: {str(e)}")

    def run(self):
        """Starts airodump-ng, ensures single-file usage for CSV/Cap, and parses them in real time."""
        try:
            if not self.adapter:
                raise ValueError("No adapter specified")

            # Channel hopping if "ALL"
            if self.channel == "ALL":
                self.channel_hop_thread = threading.Thread(target=self.hop_channels, daemon=True)
                self.channel_hop_thread.start()
            else:
                self._safe_subprocess_run(["iwconfig", self.adapter, "channel", str(self.channel)])
                self.current_channel = self.channel

            # airodump-ng command to produce current_scan-01.csv/cap
            cmd = [
                "airodump-ng",
                "--write", str(self.wardriver_dir / "current_scan"),
                "--output-format", "pcap,csv",
                "--ignore-negative-one",
                self.adapter
            ]
            if "2.4" in self.bands and "5" in self.bands:
                cmd.extend(["--band", "abg"])
            elif "5" in self.bands:
                cmd.extend(["--band", "a"])
            else:
                cmd.extend(["--band", "bg"])

            self.log(f"Starting airodump-ng with command: {' '.join(cmd)}")
            self.process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)

            # Main loop: rename current_scan-01.csv -> current_scan.csv, parse it, etc.
            while self.running:
                self._ensure_single_file()
                # Parse networks if 'current_scan.csv' exists
                if self.csv_file.exists() and self.csv_file.stat().st_size > 0:
                    self.parse_csv_for_networks(self.csv_file)

                time.sleep(3)
        except Exception as ex:
            self.log(f"Error in monitor thread: {str(ex)}", "ERROR")
        finally:
            self._finalize_scan()

    def _ensure_single_file(self):
        """
        Force the CSV and CAP files to be 'current_scan.csv' and 'current_scan.cap'.
        If airodump creates 'current_scan-01.csv/cap', rename them. Remove or ignore further files.
        """
        # 1) rename current_scan-01.csv to current_scan.csv
        csv_01 = self.wardriver_dir / "current_scan-01.csv"
        if csv_01.exists():
            if self.csv_file.exists():
                self.csv_file.unlink()
            try:
                csv_01.rename(self.csv_file)
                self.log("Renamed current_scan-01.csv -> current_scan.csv", "DEBUG")
            except Exception as e:
                self.log(f"Error renaming CSV: {str(e)}", "ERROR")

        # 2) rename current_scan-01.cap to current_scan.cap
        cap_01 = self.wardriver_dir / "current_scan-01.cap"
        if cap_01.exists():
            if self.cap_file.exists():
                self.cap_file.unlink()
            try:
                cap_01.rename(self.cap_file)
                self.log("Renamed current_scan-01.cap -> current_scan.cap", "DEBUG")
            except Exception as e:
                self.log(f"Error renaming CAP: {str(e)}", "ERROR")

        # 3) remove any other -02, -03, etc.
        for extra_csv in self.wardriver_dir.glob("current_scan-0[2-9].csv"):
            self.log(f"Removing extra CSV file: {extra_csv}", "DEBUG")
            extra_csv.unlink()
        for extra_cap in self.wardriver_dir.glob("current_scan-0[2-9].cap"):
            self.log(f"Removing extra CAP file: {extra_cap}", "DEBUG")
            extra_cap.unlink()

    def hop_channels(self):
        channels_2g = list(range(1, 15))
        channels_5g = list(range(36, 165, 4))
        while self.running:
            available_channels = []
            if "2.4" in self.bands:
                available_channels.extend(channels_2g)
            if "5" in self.bands:
                available_channels.extend(channels_5g)
            if not available_channels:
                available_channels = channels_2g

            for ch in available_channels:
                if not self.running:
                    break
                self._safe_subprocess_run(["iwconfig", self.adapter, "channel", str(ch)])
                self.current_channel = ch
                self.log(f"Hopped to channel {ch}")
                time.sleep(30)  # Increase dwell

    def parse_csv_for_networks(self, csv_file):
        """Parses current_scan.csv for networks, checks handshakes periodically."""
        try:
            self.log(f"Parsing CSV file: {csv_file}", "DEBUG")
            with csv_file.open(newline='', encoding='utf-8') as f:
                csv_reader = csv.reader(f)
                networks_section = False

                for row in csv_reader:
                    if not row:
                        continue
                    if row[0].strip() == "BSSID":
                        networks_section = True
                        continue
                    if row[0].strip() == "Station MAC":
                        break

                    if networks_section and len(row) >= 14:
                        bssid = row[0].strip()
                        channel = row[3].strip()
                        power = row[8].strip()
                        essid = row[13].strip().strip('"')
                        if bssid and essid and bssid != "(not associated)":
                            net_id = f"{essid}_{bssid}"
                            with self.networks_lock:
                                if net_id not in self.found_networks:
                                    band = "5" if channel.isdigit() and int(channel) > 14 else "2.4"
                                    self.found_networks.add(net_id)
                                    self.network_found.emit(essid, bssid, channel, band)
                                    self.log(f"Network: {essid} ({bssid}), CH={channel}, Band={band}, PWR={power}", "INFO")

            # Only check handshakes every 30 seconds or so
            now_time = time.time()
            if now_time - getattr(self, "_last_handshake_check", 0) > 30:
                if self.cap_file.exists() and self.cap_file.stat().st_size > 0:
                    self.log("Checking for handshakes...", "DEBUG")
                    self._check_handshakes(self.cap_file, timeout=30)  # pass custom timeout
                self._last_handshake_check = now_time
        except Exception as ex:
            self.log(f"Error reading CSV {csv_file}: {str(ex)}", "ERROR")


    def _check_handshakes(self, cap_file, timeout=120):
        """Check the capture file for WPA handshakes for all networks in the CSV."""
        try:
            self.log("Starting handshake verification process", "INFO")
            
            # Verify cap file exists and has content
            if not cap_file.exists():
                self.log(f"CAP file {cap_file} does not exist", "ERROR")
                return False
            if cap_file.stat().st_size == 0:
                self.log(f"CAP file {cap_file} is empty", "WARNING")
                return False

            # Extract networks from the associated CSV
            csv_file = cap_file.with_suffix(".csv")
            if not csv_file.exists():
                self.log(f"CSV file {csv_file} does not exist", "ERROR")
                return False

            networks = []
            try:
                with csv_file.open(newline='', encoding='utf-8') as f:
                    self.log("Reading CSV file for networks...", "DEBUG")
                    csv_reader = csv.reader(f)
                    networks_section = False

                    for row in csv_reader:
                        if not row:
                            continue
                        if row[0].strip() == "BSSID":
                            networks_section = True
                            continue
                        if row[0].strip() == "Station MAC":
                            break
                        
                        if networks_section and len(row) >= 14:
                            bssid = row[0].strip()
                            essid = row[13].strip().strip('"')
                            if bssid and bssid != "(not associated)" and essid:
                                privacy = row[5].strip() if len(row) > 5 else ""
                                if "WPA" in privacy:  # Only check WPA networks
                                    networks.append((essid, bssid))
                                    self.log(f"Found WPA network to check: {essid} ({bssid})", "DEBUG")

            except Exception as ex:
                self.log(f"Error reading CSV file: {str(ex)}", "ERROR")
                return False

            if not networks:
                self.log("No valid networks found to check for handshakes", "WARNING")
                return False

            # Check each network for handshakes
            handshakes_found = False
            for essid, bssid in networks:
                handshake_id = f"{essid}_{bssid}"
                if handshake_id in self.found_handshakes:
                    self.log(f"Skipping already found handshake for {essid} ({bssid})", "DEBUG")
                    continue

                self.log(f"Checking for handshake: {essid} ({bssid})", "INFO")

                # Try multiple tools for verification
                handshake_verified = False

                # 1. Try aircrack-ng
                try:
                    self.log(f"Running aircrack-ng check for {essid}", "DEBUG")
                    air_out = subprocess.run(
                        ["aircrack-ng", str(cap_file), "-b", bssid],
                        capture_output=True, text=True, timeout=30
                    )
                    self.log(f"Aircrack output for {essid}: {air_out.stdout}", "DEBUG")
                    
                    if "handshake" in air_out.stdout.lower():
                        handshake_verified = True
                        self.log(f"Aircrack-ng confirmed handshake for {essid}", "INFO")

                except Exception as ex:
                    self.log(f"Aircrack-ng check failed for {essid}: {str(ex)}", "ERROR")

                # 2. Try cowpatty as backup
                if not handshake_verified:
                    try:
                        self.log(f"Running cowpatty check for {essid}", "DEBUG")
                        cow_out = subprocess.run(
                            ["cowpatty", "-c", "-r", str(cap_file), "-s", essid],
                            capture_output=True, text=True, timeout=30
                        )
                        self.log(f"Cowpatty output for {essid}: {cow_out.stdout}", "DEBUG")

                        if "Collected all necessary data" in cow_out.stdout:
                            handshake_verified = True
                            self.log(f"Cowpatty confirmed handshake for {essid}", "INFO")

                    except Exception as ex:
                        self.log(f"Cowpatty check failed for {essid}: {str(ex)}", "ERROR")

                # If either tool verified the handshake, save it
                if handshake_verified:
                    try:
                        self._register_handshake(essid, bssid, cap_file, "verification")
                        handshakes_found = True
                    except Exception as ex:
                        self.log(f"Failed to register handshake for {essid}: {str(ex)}", "ERROR")

            return handshakes_found

        except Exception as ex:
            self.log(f"Critical error in handshake check: {str(ex)}", "ERROR")
            return False

    def _register_handshake(self, essid, bssid, cap_file, source):
        """Saves the handshake if new."""
        handshake_id = f"{essid}_{bssid}"
        with self.handshakes_lock:
            if handshake_id in self.found_handshakes:
                return
            self.found_handshakes.add(handshake_id)

        now_str = datetime.now().strftime("%Y%m%d_%H%M%S")
        dest_file = self.storage_dir / f"{essid}_{now_str}.cap"
        try:
            shutil.copy2(str(cap_file), str(dest_file))
            self.log(f"Saved handshake: {essid} ({bssid}) via {source} -> {dest_file}", "INFO")
            self.handshake_found.emit(essid, bssid)
        except Exception as e:
            self.log(f"Failed to copy handshake for {essid} ({bssid}): {str(e)}", "ERROR")

    def _finalize_scan(self):
        """Stops airodump-ng, moves current_scan files to a timestamped folder, cleans up."""
        self.running = False
        self.log("Beginning scan finalization process...", "INFO")

        # 1. Stop airodump-ng process
        if self.process:
            try:
                self.log("Terminating airodump-ng process...", "INFO")
                self.process.terminate()
                try:
                    self.process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.log("Process didn't terminate, forcing kill...", "WARNING")
                    self.process.kill()
                    self.process.wait()
                self.log("Airodump-ng process stopped", "INFO")
            except Exception as e:
                self.log(f"Error stopping airodump-ng: {str(e)}", "ERROR")

        # 2. Stop channel hopping
        if self.channel_hop_thread and self.channel_hop_thread.is_alive():
            self.log("Stopping channel hopping thread...", "INFO")
            self.channel_hop_thread.join(timeout=2)

        # 3. Wait for files to be written completely
        time.sleep(2)  # Give time for files to be written

        # 4. Final handshake check before moving files
        try:
            if self.cap_file.exists() and self.cap_file.stat().st_size > 0:
                self.log("Performing final handshake check...", "INFO")
                self._check_handshakes(self.cap_file)
        except Exception as ex:
            self.log(f"Error in final handshake check: {str(ex)}", "ERROR")

        # 5. Create timestamped folder and move files
        try:
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            dest_folder = self.wardriver_dir / ts
            self.log(f"Creating destination folder: {dest_folder}", "INFO")
            
            dest_folder.mkdir(parents=True, exist_ok=True)
            files_moved = False

            # First, handle any -01 files that might exist
            for suffix in ['.csv', '.cap']:
                orig_file = self.wardriver_dir / f"current_scan-01{suffix}"
                if orig_file.exists():
                    try:
                        if orig_file.stat().st_size > 0:
                            new_name = self.wardriver_dir / f"current_scan{suffix}"
                            self.log(f"Renaming {orig_file.name} to {new_name.name}", "INFO")
                            if new_name.exists():
                                new_name.unlink()
                            orig_file.rename(new_name)
                    except Exception as e:
                        self.log(f"Error renaming {orig_file}: {str(e)}", "ERROR")

            # Move CSV if it exists and has content
            if self.csv_file.exists():
                if self.csv_file.stat().st_size > 0:
                    new_csv = dest_folder / f"capture_{ts}.csv"
                    try:
                        self.log(f"Moving CSV file to {new_csv}", "INFO")
                        shutil.move(str(self.csv_file), str(new_csv))
                        self.log(f"Successfully moved CSV file", "INFO")
                        files_moved = True
                    except Exception as e:
                        self.log(f"Failed moving CSV: {str(e)}", "ERROR")
                else:
                    self.log("CSV file empty, deleting", "INFO")
                    self.csv_file.unlink(missing_ok=True)

            # Move CAP if it exists and has content
            if self.cap_file.exists():
                if self.cap_file.stat().st_size > 0:
                    new_cap = dest_folder / f"capture_{ts}.cap"
                    try:
                        self.log(f"Moving CAP file to {new_cap}", "INFO")
                        shutil.move(str(self.cap_file), str(new_cap))
                        self.log(f"Successfully moved CAP file", "INFO")
                        files_moved = True
                    except Exception as e:
                        self.log(f"Failed moving CAP: {str(e)}", "ERROR")
                else:
                    self.log("CAP file empty, deleting", "INFO")
                    self.cap_file.unlink(missing_ok=True)

            # Update scan history if files were moved
            if files_moved:
                try:
                    self.log("Updating scan history...", "INFO")
                    with self.networks_lock:
                        network_count = len(self.found_networks)
                    with self.handshakes_lock:
                        handshake_count = len(self.found_handshakes)
                    
                    history_file = self.wardriver_dir / "scan_history.csv"
                    history_exists = history_file.exists()
                    
                    with history_file.open('a', newline='') as f:
                        writer = csv.writer(f)
                        if not history_exists:
                            writer.writerow(['Date', 'Networks', 'Handshakes', 'Duration', 'Folder'])
                        writer.writerow([
                            datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            network_count,
                            handshake_count,
                            "N/A",  # TODO: Add duration tracking
                            ts
                        ])
                    self.log("Scan history updated", "INFO")
                except Exception as e:
                    self.log(f"Failed to update scan history: {str(e)}", "ERROR")

            # Clean up empty folder if no files were moved
            if not files_moved and dest_folder.exists():
                try:
                    dest_folder.rmdir()
                    self.log("Removed empty destination folder", "INFO")
                except Exception as e:
                    self.log(f"Failed removing empty folder: {str(e)}", "ERROR")

            # Clean up any leftover current_scan files
            for leftover in self.wardriver_dir.glob("current_scan*"):
                try:
                    leftover.unlink()
                    self.log(f"Cleaned up leftover file: {leftover.name}", "INFO")
                except Exception as e:
                    self.log(f"Failed to clean up {leftover.name}: {str(e)}", "ERROR")

        except Exception as ex:
            self.log(f"Critical error in scan finalization: {str(ex)}", "ERROR")

        self.log("Scan finalization completed", "INFO")

    def _safe_subprocess_run(self, command):
        """Helper for iwconfig commands with logging."""
        try:
            self.log(f"Running command: {' '.join(command)}", "DEBUG")
            subprocess.run(command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        except subprocess.CalledProcessError as cex:
            self.log(f"Command error: {cex.stderr}", "ERROR")
        except Exception as ex:
            self.log(f"Unknown error running {command}: {str(ex)}", "ERROR")

class Plugin:
    """Main plugin class with UI and control logic."""
    NAME = "War Driver"
    CATEGORY = "Wireless"
    DESCRIPTION = "Automatically capture WPA handshakes from nearby networks"

    def __init__(self):
        self.widget = None
        self.monitor_thread = None
        self.adapter_combo = None
        self.channel_combo = None
        self.console = None
        self.handshake_list = None
        self.networks_list = None
        self.capture_btn = None

        # Data
        self.found_handshakes = set()
        self.found_networks = set()
        self.console_visible = True
        self.networks_visible = True
        self.advanced_visible = True
        self.handshakes_visible = True
        self.auto_associate = False
        self.auto_deauth = False
        self.last_network_time = None
        self.association_thread = None
        self.network_count = 0
        self.handshake_count = 0
        self.supported_bands = {"2.4", "5"}
        
        self.networks_lock = Lock()
        self.handshakes_lock = Lock()

    # -------------------------
    #       UI Setup
    # -------------------------
    def get_widget(self):
        """Builds the main plugin UI."""
        if not self.widget:
            self.widget = QWidget()
            layout = QVBoxLayout()
            layout.setContentsMargins(0, 0, 0, 0)

            self.tab_widget = QTabWidget()
            self.tab_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            
            # 1) Scanner Tab
            scanner_tab = QWidget()
            scanner_tab.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            scanner_layout = QVBoxLayout()

            # Adapter row
            adapter_layout = QHBoxLayout()
            adapter_label = QLabel("Adapter (Monitor Mode):")
            self.adapter_combo = QComboBox()
            self.refresh_adapters()
            refresh_btn = QPushButton("Refresh")
            refresh_btn.clicked.connect(self.refresh_adapters)

            adapter_layout.addWidget(adapter_label)
            adapter_layout.addWidget(self.adapter_combo)
            adapter_layout.addWidget(refresh_btn)
            scanner_layout.addLayout(adapter_layout)

            # Buttons row
            buttons_layout = QVBoxLayout()

            # Top row
            top_buttons = QHBoxLayout()
            self.capture_btn = QPushButton("Start")
            self.capture_btn.setStyleSheet("background-color: #007bff;")  # Blue
            self.capture_btn.clicked.connect(self.toggle_capture)
            top_buttons.addWidget(self.capture_btn)

            self.console_btn = QPushButton("Console")
            self.console_btn.setCheckable(True)
            self.console_btn.setChecked(self.console_visible)
            self.console_btn.clicked.connect(lambda: self.toggle_section('console'))
            top_buttons.addWidget(self.console_btn)
            buttons_layout.addLayout(top_buttons)

            # Bottom row
            bottom_buttons = QHBoxLayout()
            self.networks_btn = QPushButton("Networks")
            self.networks_btn.setCheckable(True)
            self.networks_btn.setChecked(self.networks_visible)
            self.networks_btn.clicked.connect(lambda: self.toggle_section('networks'))
            self.networks_btn.setStyleSheet("background-color: #28a745;")
            bottom_buttons.addWidget(self.networks_btn)

            self.handshakes_btn = QPushButton("Handshakes")
            self.handshakes_btn.setCheckable(True)
            self.handshakes_btn.setChecked(self.handshakes_visible)
            self.handshakes_btn.clicked.connect(lambda: self.toggle_section('handshakes'))
            self.handshakes_btn.setStyleSheet("background-color: #28a745;")
            bottom_buttons.addWidget(self.handshakes_btn)

            clear_btn = QPushButton("Clear")
            clear_btn.clicked.connect(self.clear_console)
            bottom_buttons.addWidget(clear_btn)
            buttons_layout.addLayout(bottom_buttons)

            scanner_layout.addLayout(buttons_layout)

            # Counters
            counters_layout = QHBoxLayout()
            self.networks_count_label = QLabel("Networks: 0")
            self.networks_count_label.setFixedHeight(30)
            self.handshakes_count_label = QLabel("Handshakes: 0")
            self.handshakes_count_label.setFixedHeight(30)
            counters_layout.addWidget(self.networks_count_label)
            counters_layout.addWidget(self.handshakes_count_label)
            scanner_layout.addLayout(counters_layout)

            # Channel & Band
            channel_band_layout = QHBoxLayout()
            channel_label = QLabel("Channel:")
            self.channel_combo = QComboBox()
            self.channel_combo.addItem("ALL")
            channel_band_layout.addWidget(channel_label)
            channel_band_layout.addWidget(self.channel_combo)

            band_label = QLabel("Bands:")
            self.band_combo = QComboBox()
            channel_band_layout.addWidget(band_label)
            channel_band_layout.addWidget(self.band_combo)
            scanner_layout.addLayout(channel_band_layout)

            # Automation row
            automation_layout = QHBoxLayout()
            self.auto_associate_btn = QPushButton("Auto-Associate")
            self.auto_associate_btn.setCheckable(True)
            self.auto_associate_btn.clicked.connect(self.toggle_auto_associate)
            self.auto_associate_btn.setStyleSheet("background-color: #dc3545;")
            automation_layout.addWidget(self.auto_associate_btn)

            self.auto_deauth_btn = QPushButton("Auto-Deauth")
            self.auto_deauth_btn.setCheckable(True)
            self.auto_deauth_btn.clicked.connect(self.toggle_auto_deauth)
            self.auto_deauth_btn.setStyleSheet("background-color: #dc3545;")
            automation_layout.addWidget(self.auto_deauth_btn)
            scanner_layout.addLayout(automation_layout)

            # Networks section
            self.networks_group = QGroupBox("Found Networks")
            self.networks_group.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            networks_layout = QVBoxLayout()
            self.networks_list = QListWidget()
            self.networks_list.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            self.networks_list.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.networks_list.setWordWrap(True)
            self.networks_list.setMinimumHeight(300)
            networks_layout.addWidget(self.networks_list)
            self.networks_group.setLayout(networks_layout)
            scanner_layout.addWidget(self.networks_group)
            self.networks_group.setVisible(self.networks_visible)

            # Handshakes section
            self.handshakes_group = QGroupBox("Found Handshakes")
            handshakes_layout = QVBoxLayout()
            self.handshake_list = QListWidget()
            self.handshake_list.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            self.handshake_list.setMinimumHeight(300)
            handshakes_layout.addWidget(self.handshake_list)
            self.handshakes_group.setLayout(handshakes_layout)
            scanner_layout.addWidget(self.handshakes_group)
            self.handshakes_group.setVisible(self.handshakes_visible)

            # Console
            self.console = QTextEdit()
            self.console.setReadOnly(True)
            self.console.setFont(QFont("Monospace"))
            self.console.setVisible(self.console_visible)
            self.console.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            self.console.setMinimumHeight(300)
            scanner_layout.addWidget(self.console)

            scanner_tab.setLayout(scanner_layout)
            self.tab_widget.addTab(scanner_tab, "Scanner")

            # 2) Results Tab
            self.results_tab = QWidget()
            self.results_tab.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            results_layout = QVBoxLayout()
            
            results_sections = QHBoxLayout()

            # Handshakes table
            handshakes_group = QGroupBox("Captured Handshakes")
            handshakes_group.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            handshakes_layout = QVBoxLayout()
            self.handshakes_table = QTableWidget()
            self.handshakes_table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            self.handshakes_table.setColumnCount(3)
            self.handshakes_table.setHorizontalHeaderLabels(["ESSID", "BSSID", "Date"])
            self.handshakes_table.horizontalHeader().setStretchLastSection(True)
            self.handshakes_table.setMinimumHeight(200)
            handshakes_layout.addWidget(self.handshakes_table)
            handshakes_group.setLayout(handshakes_layout)
            results_sections.addWidget(handshakes_group)

            # Targets table
            targets_group = QGroupBox("Target Networks")
            targets_group.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            targets_layout = QVBoxLayout()
            self.targets_table = QTableWidget()
            self.targets_table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            self.targets_table.setColumnCount(4)
            self.targets_table.setHorizontalHeaderLabels(["ESSID", "BSSID", "Channel", "Added"])
            self.targets_table.horizontalHeader().setStretchLastSection(True)
            self.targets_table.setMinimumHeight(200)
            targets_layout.addWidget(self.targets_table)
            targets_group.setLayout(targets_layout)
            results_sections.addWidget(targets_group)

            # Scan history table
            history_group = QGroupBox("Scan History")
            history_group.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            history_layout = QVBoxLayout()
            self.history_table = QTableWidget()
            self.history_table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            self.history_table.setColumnCount(4)
            self.history_table.setHorizontalHeaderLabels(["Date", "Networks", "Handshakes", "Duration"])
            self.history_table.horizontalHeader().setStretchLastSection(True)
            self.history_table.setMinimumHeight(200)
            history_layout.addWidget(self.history_table)
            history_group.setLayout(history_layout)

            results_layout.addLayout(results_sections)
            results_layout.addWidget(history_group)
            self.results_tab.setLayout(results_layout)
            self.tab_widget.addTab(self.results_tab, "Results")

            layout.addWidget(self.tab_widget)
            self.widget.setLayout(layout)
            self.widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

            # Load existing results
            self.load_results()

            # Connect band combo signals
            self.band_combo.currentTextChanged.connect(self.update_channel_list)
            self.adapter_combo.currentTextChanged.connect(self.on_adapter_changed)

        return self.widget

    # -------------------------
    #       Logic
    # -------------------------
    def refresh_adapters(self):
        """Detect adapters in monitor mode."""
        try:
            output = subprocess.check_output(["iw", "dev"], stderr=subprocess.STDOUT, universal_newlines=True)
            monitor_adapters = []
            lines = output.strip().split("\n")
            current_adapter = None
            adapter_mode = None
            for line in lines:
                line = line.strip()
                if line.startswith("Interface "):
                    current_adapter = line.split()[1]
                    adapter_mode = None
                elif line.startswith("type "):
                    adapter_mode = line.split()[1]
                    if adapter_mode == "monitor" and current_adapter:
                        monitor_adapters.append(current_adapter)
                    current_adapter = None
            
            self.adapter_combo.clear()
            if monitor_adapters:
                self.adapter_combo.addItems(monitor_adapters)
                self.log_message("Found monitor mode adapters: " + ", ".join(monitor_adapters))
            else:
                self.log_error("No adapters in monitor mode found. Enable monitor mode first.")
        except subprocess.CalledProcessError as e:
            self.log_error(f"Error executing 'iw dev': {str(e)}")
        except Exception as e:
            self.log_error(f"Error refreshing adapters: {str(e)}")

    def toggle_capture(self):
        """Start or stop the scanning thread."""
        if self.monitor_thread and self.monitor_thread.isRunning():
            self.stop_monitoring()
        else:
            try:
                if not self.adapter_combo.currentText():
                    self.log_error("No monitor mode adapter selected")
                    return
                    
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Warning)
                msg.setText("Starting capture will clear all current networks and handshakes.")
                msg.setWindowTitle("Confirm Start")
                msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
                
                if msg.exec_() == QMessageBox.Ok:
                    # Clear UI lists and sets
                    self.clear_lists()
                    adapter = self.adapter_combo.currentText()
                    channel = self.channel_combo.currentText()

                    # Build band array
                    selected_band = self.band_combo.currentText()
                    if selected_band == "Both":
                        bands = ["2.4", "5"]
                    elif selected_band == "5 GHz":
                        bands = ["5"]
                    else:
                        bands = ["2.4"]

                    # Start the handshake monitor thread
                    self.monitor_thread = HandshakeMonitorThread(adapter, channel, bands)
                    self.monitor_thread.output_received.connect(self.update_console)
                    self.monitor_thread.handshake_found.connect(self.add_handshake)
                    self.monitor_thread.network_found.connect(self.add_network)

                    # Start scanning
                    self.monitor_thread.start()

                    # Update UI
                    self.capture_btn.setText("Stop")
                    self.capture_btn.setStyleSheet("background-color: #28a745;")
                    channel_info = f"channel {channel}" if channel != "ALL" else "all channels"
                    self.log_message(f"Started wardriving with {adapter} on {channel_info}")

                    # Automation
                    if self.auto_associate or self.auto_deauth:
                        self.automation_thread = threading.Thread(
                            target=self.start_network_automation, daemon=True
                        )
                        self.automation_thread.start()
            except Exception as e:
                self.log_error(f"Error starting capture: {str(e)}")
                self.stop_monitoring()

    def stop_monitoring(self):
        """Stop the monitor thread and revert UI."""
        try:
            self.auto_associate = False
            self.auto_deauth = False
            if hasattr(self, 'automation_thread'):
                time.sleep(0.5)

            if self.monitor_thread:
                self.log_message("Attempting graceful shutdown of the monitor thread...")
                self.monitor_thread.running = False
                start_time = time.time()
                while self.monitor_thread.isRunning() and (time.time() - start_time) < 5:
                    time.sleep(0.1)

                if self.monitor_thread.isRunning():
                    self.log_message("Forcing termination of the thread...")
                    try:
                        self.monitor_thread.terminate()
                        start_time = time.time()
                        while self.monitor_thread.isRunning() and (time.time() - start_time) < 2:
                            time.sleep(0.1)
                        if self.monitor_thread.isRunning() and self.monitor_thread.process:
                            self.log_message("Killing airodump-ng process forcibly...")
                            self.monitor_thread.process.kill()
                    except Exception as ex:
                        self.log_error(f"Error killing thread: {str(ex)}")
            
            self.monitor_thread = None
            self.capture_btn.setText("Start")
            self.capture_btn.setStyleSheet("background-color: #007bff;")
            self.log_message("Monitor thread stopped")

            # Refresh results in the UI
            self.tab_widget.setCurrentWidget(self.results_tab)
            self.load_results()
        except Exception as e:
            self.log_error(f"Error in stop_monitoring: {str(e)}")

    # -------------------------
    #       UI Updates
    # -------------------------
    def add_network(self, essid, bssid, channel, band):
        """Add a found network to the UI list if not already present."""
        network_id = f"{essid} ({bssid})"
        with self.networks_lock:
            if network_id in self.found_networks:
                return  # skip duplicates
            self.found_networks.add(network_id)

        # Create UI row
        network_widget = QWidget()
        network_layout = QHBoxLayout(network_widget)
        network_layout.setContentsMargins(5, 5, 5, 5)

        # "Target" button
        target_btn = QPushButton("Target")
        target_btn.setFixedWidth(80)
        target_btn.setStyleSheet("background-color: #dc3545;")
        network_layout.addWidget(target_btn)

        # Label
        network_label = QLabel(f"{essid} ({bssid}) - CH:{channel} {band}GHz")
        network_layout.addWidget(network_label)

        # Check if target file exists
        targets_dir = Path("/nsatt/storage/saves/wireless/targets")
        targets_dir.mkdir(parents=True, exist_ok=True)
        target_file = targets_dir / f"{essid}.txt"
        if target_file.exists():
            try:
                if target_file.read_text().strip():
                    target_btn.setStyleSheet("background-color: #28a745;")
                    target_btn.setEnabled(False)
            except Exception as ex:
                self.log_message(f"Error reading target file: {str(ex)}")

        # Connect button
        target_btn.clicked.connect(lambda: self.create_target_file(essid, bssid, channel, target_btn))

        item = QListWidgetItem()
        item.setSizeHint(network_widget.sizeHint())
        self.networks_list.addItem(item)
        self.networks_list.setItemWidget(item, network_widget)

        # Update counters
        self.network_count += 1
        self.networks_count_label.setText(f"Networks: {self.network_count}")

    def create_target_file(self, essid, bssid, channel, target_btn):
        """Create a target file for a network."""
        try:
            targets_dir = Path("/nsatt/storage/saves/wireless/targets")
            targets_dir.mkdir(parents=True, exist_ok=True)
            target_file = targets_dir / f"{essid}.txt"

            # Write target info to file
            with target_file.open('w') as f:
                f.write(f"ESSID: {essid}\n")
                f.write(f"BSSID: {bssid}\n") 
                f.write(f"Channel: {channel}\n")
                f.write(f"Added: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")

            # Update button appearance
            target_btn.setStyleSheet("background-color: #28a745;")
            target_btn.setEnabled(False)

            # Update targets table
            row = self.targets_table.rowCount()
            self.targets_table.insertRow(row)
            self.targets_table.setItem(row, 0, QTableWidgetItem(essid))
            self.targets_table.setItem(row, 1, QTableWidgetItem(bssid))
            self.targets_table.setItem(row, 2, QTableWidgetItem(str(channel)))
            self.targets_table.setItem(row, 3, QTableWidgetItem(datetime.now().strftime('%Y-%m-%d %H:%M:%S')))

            self.log_message(f"Added target: {essid}")

        except Exception as ex:
            self.log_error(f"Error creating target file: {str(ex)}")


    def add_handshake(self, essid, bssid):
        """Add handshake to UI list if not already present."""
        handshake_id = f"{essid} ({bssid})"
        with self.handshakes_lock:
            if handshake_id in self.found_handshakes:
                return
            self.found_handshakes.add(handshake_id)

        self.handshake_list.addItem(handshake_id)
        self.handshake_count += 1
        self.handshakes_count_label.setText(f"Handshakes: {self.handshake_count}")

    def update_console(self, text):
        """Append log messages to the console."""
        if self.console:
            self.console.append(text)

    def clear_lists(self):
        """Clear UI lists and reset sets."""
        if self.console:
            self.console.clear()
        if self.networks_list:
            self.networks_list.clear()
        if self.handshake_list:
            self.handshake_list.clear()
        self.found_networks.clear()
        self.found_handshakes.clear()

    def clear_console(self):
        """Clear console and found networks list only."""
        if self.console:
            self.console.clear()
        if self.networks_list:
            self.networks_list.clear()

    def toggle_section(self, section):
        """Show/hide sections in the UI."""
        if section == 'console':
            self.console_visible = not self.console_visible
            self.console.setVisible(self.console_visible)
            self.console_btn.setChecked(self.console_visible)
            self.console_btn.setStyleSheet("background-color: #28a745;" if self.console_visible else "background-color: #dc3545;")
        elif section == 'networks':
            self.networks_visible = not self.networks_visible
            self.networks_group.setVisible(self.networks_visible)
            self.networks_btn.setChecked(self.networks_visible)
            self.networks_btn.setStyleSheet("background-color: #28a745;" if self.networks_visible else "background-color: #dc3545;")
        elif section == 'handshakes':
            self.handshakes_visible = not self.handshakes_visible
            self.handshakes_group.setVisible(self.handshakes_visible)
            self.handshakes_btn.setChecked(self.handshakes_visible)
            self.handshakes_btn.setStyleSheet("background-color: #28a745;" if self.handshakes_visible else "background-color: #dc3545;")

    # -------------------------
    #       Results
    # -------------------------
    def load_results(self):
        """Load previous scans' handshakes, targets, and history tables."""
        self.load_handshakes()
        self.load_targets()
        self.load_scan_history()


    def load_handshakes(self):
        """
        Load existing handshake files (e.g. ESSID_20241228_045945.cap)
        from /nsatt/storage/saves/wireless/handshakes.
        Then parse them to find ESSID, BSSID, and timestamp.
        """
        self.handshakes_table.setRowCount(0)
        storage_dir = Path("/nsatt/storage/saves/wireless/handshakes")
        if not storage_dir.exists():
            storage_dir.mkdir(parents=True, exist_ok=True)
            return

        for cap_file in storage_dir.glob("*.cap"):
            try:
                name_parts = cap_file.stem.split('_')
                # e.g. "MyNetwork_20241228_045945"
                essid = name_parts[0]
                timestamp_str = '_'.join(name_parts[1:])
                try:
                    ts = datetime.strptime(timestamp_str, "%Y%m%d_%H%M%S")
                except ValueError:
                    # fallback if we can't parse the timestamp
                    ts = datetime.fromtimestamp(cap_file.stat().st_mtime)

                # Try both tools to find BSSID
                bssid_found = None

                # Try aircrack-ng first
                try:
                    air_out = subprocess.run(
                        ["aircrack-ng", str(cap_file)],
                        capture_output=True,
                        text=True,
                        timeout=15
                    )
                    if air_out.returncode == 0:
                        for line in air_out.stdout.splitlines():
                            if "WPA" in line and "handshake" in line:
                                match = re.search(r"([^\s]+)\s+\(([0-9A-F:]{17})\)", line)
                                if match:
                                    bssid_found = match.group(2)
                                    break
                except (subprocess.TimeoutExpired, subprocess.CalledProcessError):
                    pass

                # If aircrack didn't find it, try cowpatty
                if not bssid_found:
                    try:
                        cow_out = subprocess.run(
                            ["cowpatty", "-c", "-r", str(cap_file)],
                            capture_output=True,
                            text=True,
                            timeout=15
                        )
                        if cow_out.returncode == 0:
                            bssid_match = re.search(r"BSSID\s*:\s*([0-9A-F:]{17})", cow_out.stdout)
                            if bssid_match:
                                bssid_found = bssid_match.group(1)
                    except (subprocess.TimeoutExpired, subprocess.CalledProcessError):
                        pass

                # Add to table if we found a BSSID
                if bssid_found:
                    row = self.handshakes_table.rowCount()
                    self.handshakes_table.insertRow(row)
                    self.handshakes_table.setItem(row, 0, QTableWidgetItem(essid))
                    self.handshakes_table.setItem(row, 1, QTableWidgetItem(bssid_found))
                    self.handshakes_table.setItem(row, 2, QTableWidgetItem(ts.strftime("%Y-%m-%d %H:%M")))
            except Exception as e:
                self.log_error(f"Error loading handshake {cap_file}: {e}")


    def load_targets(self):
        """
        Load target networks from /nsatt/storage/saves/wireless/targets
        (each .txt file has BSSID, Channel, etc.)
        """
        self.targets_table.setRowCount(0)
        targets_dir = Path("/nsatt/storage/saves/wireless/targets")
        if not targets_dir.exists():
            targets_dir.mkdir(parents=True, exist_ok=True)
            return

        for target_file in targets_dir.glob("*.txt"):
            try:
                content = target_file.read_text(encoding="utf-8")
                essid = target_file.stem

                bssid_match = re.search(r"BSSID:\s*([0-9A-F:]{17})", content)
                channel_match = re.search(r"Channel:\s*(\d+)", content)
                added_match = re.search(r"Added:\s*(.+)", content)

                if bssid_match:
                    row = self.targets_table.rowCount()
                    self.targets_table.insertRow(row)
                    self.targets_table.setItem(row, 0, QTableWidgetItem(essid))
                    self.targets_table.setItem(row, 1, QTableWidgetItem(bssid_match.group(1)))
                    if channel_match:
                        self.targets_table.setItem(row, 2, QTableWidgetItem(channel_match.group(1)))
                    if added_match:
                        self.targets_table.setItem(row, 3, QTableWidgetItem(added_match.group(1)))
            except Exception as ex:
                self.log_error(f"Error loading target {target_file}: {ex}")


    def load_scan_history(self):
        """Load previous scans from scan_history.csv into the history table."""
        try:
            history_file = Path("/nsatt/storage/saves/wireless/wardriver/scan_history.csv")
            if not history_file.exists():
                return

            self.history_table.setRowCount(0)
            with history_file.open('r', newline='') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    current_row = self.history_table.rowCount()
                    self.history_table.insertRow(current_row)
                    
                    # Date
                    self.history_table.setItem(current_row, 0, QTableWidgetItem(row['Date']))
                    # Networks
                    self.history_table.setItem(current_row, 1, QTableWidgetItem(row['Networks']))
                    # Handshakes
                    self.history_table.setItem(current_row, 2, QTableWidgetItem(row['Handshakes']))
                    # Duration
                    self.history_table.setItem(current_row, 3, QTableWidgetItem(row['Duration']))

        except Exception as ex:
            self.log_error(f"Error loading scan history: {str(ex)}")

    # -------------------------
    #       Automation
    # -------------------------
    def start_network_automation(self):
        """Auto-Associate or Deauth networks if enabled."""
        while self.monitor_thread and self.monitor_thread.isRunning():
            try:
                current_time = time.time()
                if self.last_network_time and (current_time - self.last_network_time) > 60:
                    self.log_message("No new networks for 1 minute, waiting another minute...")
                    time.sleep(60)
                    if (time.time() - self.last_network_time) > 120:
                        if self.auto_associate or self.auto_deauth:
                            self.log_message("Starting automatic network interactions...")
                            current_channel = self.monitor_thread.current_channel
                            with self.networks_lock:
                                current_channel_networks = [
                                    net for net in list(self.found_networks)
                                    if self.get_network_channel(net) == current_channel
                                ]
                            for network in current_channel_networks:
                                if not self.monitor_thread.isRunning():
                                    break
                                essid, bssid = self.parse_network_string(network)
                                if not essid or not bssid:
                                    continue
                                if self.auto_associate:
                                    self.log_message(f"Attempting to associate with {essid}")
                                    self.associate_with_network(essid, bssid)
                                if self.auto_deauth:
                                    self.log_message(f"Sending deauth packets to {essid}")
                                    self.deauth_network(bssid)
                                time.sleep(random.uniform(10, 30))
                            self.last_network_time = time.time()
                time.sleep(5)
            except Exception as ex:
                self.log_error(f"Error in network automation: {ex}")
                time.sleep(5)

    def parse_network_string(self, network_string):
        """Extract ESSID and BSSID from 'ESSID (BSSID)'."""
        try:
            match = re.match(r"(.+?)\s*\(([0-9A-F:]{17})\)", network_string)
            if match:
                return match.group(1), match.group(2)
        except Exception as e:
            self.log_error(f"Error parsing network string: {str(e)}")
        return None, None

    def get_network_channel(self, network_string):
        """Extract channel from 'ESSID (BSSID) - CH:X' format."""
        try:
            match = re.search(r"CH:(\d+)", network_string)
            if match:
                return int(match.group(1))
        except Exception as e:
            self.log_error(f"Error extracting channel: {str(e)}")
        return None

    def associate_with_network(self, essid, bssid):
        """Associate with the given ESSID/BSSID."""
        try:
            cmd = ["iwconfig", self.adapter_combo.currentText(), "essid", essid, "ap", bssid]
            result = subprocess.run(cmd, timeout=10, capture_output=True, text=True)
            if result.returncode == 0:
                self.log_message(f"Successfully associated with {essid}")
            else:
                self.log_error(f"Association failed with {essid}: {result.stderr}")
        except Exception as ex:
            self.log_error(f"Association failed with {essid}: {str(ex)}")

    def deauth_network(self, bssid):
        """Send deauth packets via aireplay-ng."""
        try:
            cmd = ["aireplay-ng", "--deauth", "5", "-a", bssid, self.adapter_combo.currentText()]
            result = subprocess.run(cmd, timeout=10, capture_output=True, text=True)
            if result.returncode == 0:
                self.log_message(f"Sent deauth packets to {bssid}")
            else:
                self.log_error(f"Deauth failed for {bssid}: {result.stderr}")
        except Exception as ex:
            self.log_error(f"Deauth failed for {bssid}: {str(ex)}")

    # -------------------------
    #       Helpers
    # -------------------------
    def log_message(self, message):
        """Log message to the console in [INFO] style."""
        if self.console:
            self.console.append(f"[INFO] {message}")

    def log_error(self, message):
        """Log message to the console in [ERROR] style."""
        if self.console:
            self.console.append(f"[ERROR] {message}")

    def toggle_auto_associate(self):
        self.auto_associate = not self.auto_associate
        self.auto_associate_btn.setStyleSheet(
            "background-color: #28a745;" if self.auto_associate else "background-color: #dc3545;"
        )

    def toggle_auto_deauth(self):
        self.auto_deauth = not self.auto_deauth
        self.auto_deauth_btn.setStyleSheet(
            "background-color: #28a745;" if self.auto_deauth else "background-color: #dc3545;"
        )

    def on_adapter_changed(self):
        """When adapter changes, re-detect supported bands."""
        try:
            self.supported_bands = self.detect_supported_bands()
            current_text = self.band_combo.currentText()
            self.band_combo.clear()

            # Populate band_combo
            if "2.4" in self.supported_bands:
                self.band_combo.addItem("2.4 GHz")
            if "5" in self.supported_bands:
                self.band_combo.addItem("5 GHz")
            if "2.4" in self.supported_bands and "5" in self.supported_bands:
                self.band_combo.addItem("Both")

            # Try to restore previous selection
            idx = self.band_combo.findText(current_text)
            if idx >= 0:
                self.band_combo.setCurrentIndex(idx)
            else:
                self.band_combo.setCurrentIndex(0)

            self.update_channel_list()
        except Exception as ex:
            self.log_error(f"Error updating band selection: {str(ex)}")

    def detect_supported_bands(self):
        """Use `iw list` to see which bands the adapter supports."""
        bands = set()
        try:
            adapter = self.adapter_combo.currentText()
            if not adapter:
                return {"2.4", "5"}

            out = subprocess.check_output(["iw", "list"], text=True)
            if "2400 MHz" in out:
                bands.add("2.4")
            if "5000 MHz" in out:
                bands.add("5")
            self.log_message(f"Detected bands: {', '.join(sorted(bands))} GHz")
        except Exception as ex:
            self.log_error(f"Error detecting bands: {str(ex)}")
            bands = {"2.4", "5"}
        return bands

    def update_channel_list(self):
        """Update channel choices based on selected band."""
        try:
            self.channel_combo.clear()
            self.channel_combo.addItem("ALL")
            selected_band = self.band_combo.currentText()
            if selected_band in ["2.4 GHz", "Both"]:
                for ch in range(1, 15):
                    self.channel_combo.addItem(str(ch))
            if selected_band in ["5 GHz", "Both"]:
                for ch in range(36, 165, 4):
                    self.channel_combo.addItem(str(ch))
        except Exception as ex:
            self.log_error(f"Error updating channel list: {str(ex)}")

    def initialize(self):
        """Optional plugin initialization."""
        try:
            return True
        except Exception as ex:
            self.log_error(f"Error in initialization: {str(ex)}")
            return False

    def terminate(self):
        """Cleanup on plugin termination."""
        try:
            self.stop_monitoring()
        except Exception as ex:
            self.log_error(f"Error in termination: {str(ex)}")
    # -------------------------------------------------
